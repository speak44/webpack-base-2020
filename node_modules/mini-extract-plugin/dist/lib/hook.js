"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const tapable_1 = require("tapable");
const debug_1 = __importDefault(require("./debug"));
const hook_definition_1 = require("./hook-definition");
const asyncHooks = [
    tapable_1.AsyncParallelBailHook,
    tapable_1.AsyncParallelHook,
    tapable_1.AsyncSeriesBailHook,
    tapable_1.AsyncSeriesHook,
    tapable_1.AsyncSeriesWaterfallHook,
];
function create() {
    return hook_definition_1.hooksFromDefinitions();
}
exports.create = create;
function isHookAsync(hook) {
    return asyncHooks.some((aHook) => hook instanceof aHook);
}
exports.isHookAsync = isHookAsync;
function tapMany(pluginName, hooksObj, overrides) {
    for (const { name, type: tapType, hooks: hookFuncs } of overrides) {
        if (!hooksObj[name]) {
            throw Error(`Unknown hook name ${name}.`);
        }
        debug_1.default(`Applying ${hookFuncs.length} hook(s) ${name} (${tapType}) to ${pluginName}`);
        for (const hookFunc of hookFuncs) {
            hooksObj[name][tapType](pluginName, hookFunc);
        }
    }
}
exports.tapMany = tapMany;
function callTap({ name, hooks, args, default: defaultVal, }) {
    const tap = hooks[name];
    if (!tap.isUsed()) {
        debug_1.default(`Hook "${name}" is not used, using default value`);
        return defaultVal;
    }
    debug_1.default(`Started hook "${name}"`);
    const result = isHookAsync(tap) ? tap.promise(...args) : tap.call(...args);
    debug_1.default(`Done hook "${name}"`);
    return result;
}
exports.callTap = callTap;
