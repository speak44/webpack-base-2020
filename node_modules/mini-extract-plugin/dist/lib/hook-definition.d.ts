import type { Source } from 'webpack-sources';
import type { CompilationContext, CompilerContext, PitchContext, LoaderModuleContext, PitchCompilerContext, PitchCompilationContext, RenderContext } from '../types/context';
import type { RenderManifestEntry } from '../types/webpack';
import type { AbstractMiniExtractPlugin } from '../types/subclassing-abstract';
export declare function getDefinitions<MEP extends AbstractMiniExtractPlugin = AbstractMiniExtractPlugin>(): {
    initialize: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncHook<any, any, any>;
        args: [{
            name: "instance";
            type: MEP;
        }, {
            name: "options";
            type: MEP["options"];
        }];
        return: {
            name: null;
            type: void;
        };
    };
    compiler: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncHook<any, any, any>;
        args: [{
            name: "compilerContext";
            type: CompilerContext<MEP>;
        }];
        return: {
            name: null;
            type: void;
        };
    };
    compilation: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncHook<any, any, any>;
        args: [{
            name: "compilationContext";
            type: CompilationContext<MEP>;
        }];
        return: {
            name: null;
            type: void;
        };
    };
    beforeRenderMain: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncWaterfallHook<any, any, any>;
        args: [{
            name: "renderContext";
            type: RenderContext<MEP>;
        }, {
            name: "modules";
            type: InstanceType<MEP["classOptions"]["moduleClass"]>[];
        }];
        return: {
            name: null;
            type: InstanceType<MEP["classOptions"]["moduleClass"]>[] | InstanceType<MEP["classOptions"]["moduleClass"]>[][];
        };
    };
    renderMain: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncWaterfallHook<any, any, any>;
        args: [{
            name: "renderContext";
            type: RenderContext<MEP>;
        }, {
            name: "moduleGroups";
            type: InstanceType<MEP["classOptions"]["moduleClass"]>[][];
        }];
        return: {
            name: null;
            type: RenderManifestEntry[];
        };
    };
    afterRenderMain: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncHook<any, any, any>;
        args: [{
            name: "renderContext";
            type: RenderContext<MEP>;
        }, {
            name: "renderManifestEntries";
            type: RenderManifestEntry[];
        }];
        return: {
            name: null;
            type: void;
        };
    };
    beforeRenderChunk: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncWaterfallHook<any, any, any>;
        args: [{
            name: "renderContext";
            type: RenderContext<MEP>;
        }, {
            name: "modules";
            type: InstanceType<MEP["classOptions"]["moduleClass"]>[];
        }];
        return: {
            name: null;
            type: InstanceType<MEP["classOptions"]["moduleClass"]>[] | InstanceType<MEP["classOptions"]["moduleClass"]>[][];
        };
    };
    renderChunk: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncWaterfallHook<any, any, any>;
        args: [{
            name: "renderContext";
            type: RenderContext<MEP>;
        }, {
            name: "moduleGroups";
            type: InstanceType<MEP["classOptions"]["moduleClass"]>[][];
        }];
        return: {
            name: null;
            type: RenderManifestEntry[];
        };
    };
    afterRenderChunk: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncHook<any, any, any>;
        args: [{
            name: "renderContext";
            type: RenderContext<MEP>;
        }, {
            name: "renderManifestEntries";
            type: RenderManifestEntry[];
        }];
        return: {
            name: null;
            type: void;
        };
    };
    beforeMerge: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncWaterfallHook<any, any, any>;
        args: [{
            name: "renderContext";
            type: RenderContext<MEP>;
        }, {
            name: "modules";
            type: InstanceType<MEP["classOptions"]["moduleClass"]>[];
        }];
        return: {
            name: null;
            type: InstanceType<MEP["classOptions"]["moduleClass"]>[];
        };
    };
    merge: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncWaterfallHook<any, any, any>;
        args: [{
            name: "renderContext";
            type: RenderContext<MEP>;
        }, {
            name: "modules";
            type: InstanceType<MEP["classOptions"]["moduleClass"]>[];
        }];
        return: {
            name: null;
            type: Source;
        };
    };
    afterMerge: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncHook<any, any, any>;
        args: [{
            name: "renderContext";
            type: RenderContext<MEP>;
        }, {
            name: "resultSource";
            type: Source;
        }];
        return: {
            name: null;
            type: void;
        };
    };
    pitch: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").AsyncParallelHook<any, any, any>;
        args: [{
            name: "pitchContext";
            type: PitchContext<MEP>;
        }];
        return: {
            name: null;
            type: void;
        };
    };
    childCompiler: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").AsyncParallelHook<any, any, any>;
        args: [{
            name: "pitchCompilerContext";
            type: PitchCompilerContext<MEP>;
        }];
        return: {
            name: null;
            type: void;
        };
    };
    source: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").AsyncSeriesWaterfallHook<any, any, any>;
        args: [{
            name: "pitchCompilationContext";
            type: PitchCompilationContext<MEP>;
        }];
        return: {
            name: null;
            type: string;
        };
    };
    childCompilation: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncHook<any, any, any>;
        args: [{
            name: "pitchCompilationContext";
            type: PitchCompilationContext<MEP>;
        }];
        return: {
            name: null;
            type: void;
        };
    };
    dependency: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncWaterfallHook<any, any, any>;
        args: [{
            name: "pitchCompilationContext";
            type: PitchCompilationContext<MEP>;
        }, {
            name: "loaderModuleContext";
            type: LoaderModuleContext;
        }];
        return: {
            name: null;
            type: ConstructorParameters<MEP["classOptions"]["dependencyClass"]>[0][];
        };
    };
    extracted: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncWaterfallHook<any, any, any>;
        args: [{
            name: "pitchCompilationContext";
            type: PitchCompilationContext<MEP>;
        }, {
            name: "remainingSource";
            type: string;
        }];
        return: {
            name: null;
            type: string;
        };
    };
};
export declare function hooksFromDefinitions<MEP extends AbstractMiniExtractPlugin = AbstractMiniExtractPlugin>(): {};
