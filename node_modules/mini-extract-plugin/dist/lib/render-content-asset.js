"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const webpack_sources_1 = require("webpack-sources");
const hook_1 = require("./hook");
const debug_1 = __importDefault(require("./debug"));
function renderContentAsset({ context, modules, ignoreOrder }) {
    debug_1.default('Started renderContentAsset');
    const { plugin, compilation, classOptions: { pluginName }, renderOptions: { chunk }, } = context;
    const { requestShortener } = compilation.runtimeTemplate;
    const usedModulesSet = new Set();
    const [chunkGroup] = chunk.groupsIterable;
    if (typeof chunkGroup.getModuleIndex2 === 'function') {
        const moduleDependencies = new Map(modules.map((m) => [m, new Set()]));
        const moduleDependenciesReasons = new Map(modules.map((m) => [m, new Map()]));
        const modulesByChunkGroup = Array.from(chunk.groupsIterable, (cg) => {
            const sortedModules = modules
                .map((m) => {
                return {
                    module: m,
                    index: cg.getModuleIndex2(m),
                };
            })
                .filter((item) => item.index !== undefined)
                .sort((a, b) => b.index - a.index)
                .map((item) => item.module);
            for (let i = 0; i < sortedModules.length; i++) {
                const set = moduleDependencies.get(sortedModules[i]);
                const reasons = moduleDependenciesReasons.get(sortedModules[i]);
                for (let j = i + 1; j < sortedModules.length; j++) {
                    const module = sortedModules[j];
                    set.add(module);
                    const reason = reasons.get(module) || new Set();
                    reason.add(cg);
                    reasons.set(module, reason);
                }
            }
            return sortedModules;
        });
        const unusedModulesFilter = (m) => !usedModulesSet.has(m);
        while (usedModulesSet.size < modules.length) {
            let success = false;
            let bestMatch = [];
            let bestMatchDeps = [];
            for (const list of modulesByChunkGroup) {
                while (list.length > 0 && usedModulesSet.has(list[list.length - 1])) {
                    list.pop();
                }
                if (list.length !== 0) {
                    const module = list[list.length - 1];
                    const deps = moduleDependencies.get(module);
                    const failedDeps = Array.from(deps).filter(unusedModulesFilter);
                    if (!bestMatchDeps || bestMatchDeps.length > failedDeps.length) {
                        bestMatch = list;
                        bestMatchDeps = failedDeps;
                    }
                    if (failedDeps.length === 0) {
                        usedModulesSet.add(list.pop());
                        success = true;
                        break;
                    }
                }
            }
            if (!success) {
                const fallbackModule = bestMatch.pop();
                if (!ignoreOrder) {
                    const reasons = moduleDependenciesReasons.get(fallbackModule);
                    compilation.warnings.push(new Error([
                        `chunk ${chunk.name || chunk.id} [${pluginName}]`,
                        'Conflicting order. Following module has been added:',
                        ` * ${fallbackModule.readableIdentifier(requestShortener)}`,
                        'despite it was not able to fulfill desired ordering with these modules:',
                        ...bestMatchDeps.map((m) => {
                            const goodReasonsMap = moduleDependenciesReasons.get(m);
                            const goodReasons = goodReasonsMap && goodReasonsMap.get(fallbackModule);
                            const failedChunkGroups = Array.from(reasons.get(m), (cg) => cg.name).join(', ');
                            const goodChunkGroups = goodReasons &&
                                Array.from(goodReasons, (cg) => cg.name).join(', ');
                            return [
                                ` * ${m.readableIdentifier(requestShortener)}`,
                                `   - couldn't fulfill desired order of chunk group(s) ${failedChunkGroups}`,
                                goodChunkGroups &&
                                    `   - while fulfilling desired order of chunk group(s) ${goodChunkGroups}`,
                            ]
                                .filter(Boolean)
                                .join('\n');
                        }),
                    ].join('\n')));
                }
                usedModulesSet.add(fallbackModule);
            }
        }
    }
    else {
        modules
            .sort((a, b) => a.index2 - b.index2)
            .forEach((m) => usedModulesSet.add(m));
    }
    const usedModules = hook_1.callTap({
        name: 'beforeMerge',
        hooks: plugin.hooks,
        args: [context, Array.from(usedModulesSet), undefined],
        default: Array.from(usedModulesSet),
    });
    let result = hook_1.callTap({
        name: 'merge',
        hooks: plugin.hooks,
        args: [context, usedModules, undefined],
    });
    if (result) {
        hook_1.callTap({
            name: 'afterMerge',
            hooks: plugin.hooks,
            args: [context, result, undefined],
        });
        return result;
    }
    debug_1.default('Hook merge is not used, running default implementation instead');
    const source = new webpack_sources_1.ConcatSource();
    for (const mod of usedModules) {
        source.add(new webpack_sources_1.OriginalSource(mod.content, mod.readableIdentifier(requestShortener)));
        source.add('\n');
    }
    source.add('\n');
    result = new webpack_sources_1.ConcatSource(source);
    hook_1.callTap({
        name: 'afterMerge',
        hooks: plugin.hooks,
        args: [context, result, undefined],
    });
    debug_1.default('Done renderContentAsset');
    return result;
}
exports.default = renderContentAsset;
