import { Hook } from 'tapable';
import type { AnyFunc } from '../types/util';
import type { MiniExtractPlugin } from '../types/subclassing';
import type { Collection, Overrides, ActiveHooks, Taps, ActiveHookNames, ActiveAsyncHookNames } from '../types/hook';
export declare function create<MEP extends MiniExtractPlugin = MiniExtractPlugin>(): import("../types/hook").Hooks<{
    initialize: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncHook<any, any, any>;
        args: [{
            name: "instance";
            type: import("../types/subclassing-abstract").AbstractMiniExtractPlugin<{}, import("../types/subclassing-params").ParamsParse<{}>>;
        }, {
            name: "options";
            type: import("../types/subclassing-classes").ConstructorOptions;
        }];
        return: {
            name: null;
            type: void;
        };
    };
    compiler: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncHook<any, any, any>;
        args: [{
            name: "compilerContext";
            type: import("../types/context").CompilerContext<import("../types/subclassing-abstract").AbstractMiniExtractPlugin<{}, import("../types/subclassing-params").ParamsParse<{}>>>;
        }];
        return: {
            name: null;
            type: void;
        };
    };
    compilation: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncHook<any, any, any>;
        args: [{
            name: "compilationContext";
            type: import("../types/context").CompilationContext<import("../types/subclassing-abstract").AbstractMiniExtractPlugin<{}, import("../types/subclassing-params").ParamsParse<{}>>>;
        }];
        return: {
            name: null;
            type: void;
        };
    };
    beforeRenderMain: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncWaterfallHook<any, any, any>;
        args: [{
            name: "renderContext";
            type: import("../types/context").RenderContext<import("../types/subclassing-abstract").AbstractMiniExtractPlugin<{}, import("../types/subclassing-params").ParamsParse<{}>>>;
        }, {
            name: "modules";
            type: import("../types/subclassing-classes").Module[];
        }];
        return: {
            name: null;
            type: import("../types/subclassing-classes").Module[] | import("../types/subclassing-classes").Module[][];
        };
    };
    renderMain: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncWaterfallHook<any, any, any>;
        args: [{
            name: "renderContext";
            type: import("../types/context").RenderContext<import("../types/subclassing-abstract").AbstractMiniExtractPlugin<{}, import("../types/subclassing-params").ParamsParse<{}>>>;
        }, {
            name: "moduleGroups";
            type: import("../types/subclassing-classes").Module[][];
        }];
        return: {
            name: null;
            type: import("../types/webpack").RenderManifestEntry[];
        };
    };
    afterRenderMain: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncHook<any, any, any>;
        args: [{
            name: "renderContext";
            type: import("../types/context").RenderContext<import("../types/subclassing-abstract").AbstractMiniExtractPlugin<{}, import("../types/subclassing-params").ParamsParse<{}>>>;
        }, {
            name: "renderManifestEntries";
            type: import("../types/webpack").RenderManifestEntry[];
        }];
        return: {
            name: null;
            type: void;
        };
    };
    beforeRenderChunk: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncWaterfallHook<any, any, any>;
        args: [{
            name: "renderContext";
            type: import("../types/context").RenderContext<import("../types/subclassing-abstract").AbstractMiniExtractPlugin<{}, import("../types/subclassing-params").ParamsParse<{}>>>;
        }, {
            name: "modules";
            type: import("../types/subclassing-classes").Module[];
        }];
        return: {
            name: null;
            type: import("../types/subclassing-classes").Module[] | import("../types/subclassing-classes").Module[][];
        };
    };
    renderChunk: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncWaterfallHook<any, any, any>;
        args: [{
            name: "renderContext";
            type: import("../types/context").RenderContext<import("../types/subclassing-abstract").AbstractMiniExtractPlugin<{}, import("../types/subclassing-params").ParamsParse<{}>>>;
        }, {
            name: "moduleGroups";
            type: import("../types/subclassing-classes").Module[][];
        }];
        return: {
            name: null;
            type: import("../types/webpack").RenderManifestEntry[];
        };
    };
    afterRenderChunk: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncHook<any, any, any>;
        args: [{
            name: "renderContext";
            type: import("../types/context").RenderContext<import("../types/subclassing-abstract").AbstractMiniExtractPlugin<{}, import("../types/subclassing-params").ParamsParse<{}>>>;
        }, {
            name: "renderManifestEntries";
            type: import("../types/webpack").RenderManifestEntry[];
        }];
        return: {
            name: null;
            type: void;
        };
    };
    beforeMerge: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncWaterfallHook<any, any, any>;
        args: [{
            name: "renderContext";
            type: import("../types/context").RenderContext<import("../types/subclassing-abstract").AbstractMiniExtractPlugin<{}, import("../types/subclassing-params").ParamsParse<{}>>>;
        }, {
            name: "modules";
            type: import("../types/subclassing-classes").Module[];
        }];
        return: {
            name: null;
            type: import("../types/subclassing-classes").Module[];
        };
    };
    merge: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncWaterfallHook<any, any, any>;
        args: [{
            name: "renderContext";
            type: import("../types/context").RenderContext<import("../types/subclassing-abstract").AbstractMiniExtractPlugin<{}, import("../types/subclassing-params").ParamsParse<{}>>>;
        }, {
            name: "modules";
            type: import("../types/subclassing-classes").Module[];
        }];
        return: {
            name: null;
            type: import("webpack-sources").Source;
        };
    };
    afterMerge: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncHook<any, any, any>;
        args: [{
            name: "renderContext";
            type: import("../types/context").RenderContext<import("../types/subclassing-abstract").AbstractMiniExtractPlugin<{}, import("../types/subclassing-params").ParamsParse<{}>>>;
        }, {
            name: "resultSource";
            type: import("webpack-sources").Source;
        }];
        return: {
            name: null;
            type: void;
        };
    };
    pitch: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").AsyncParallelHook<any, any, any>;
        args: [{
            name: "pitchContext";
            type: import("../types/context").PitchContext<import("../types/subclassing-abstract").AbstractMiniExtractPlugin<{}, import("../types/subclassing-params").ParamsParse<{}>>>;
        }];
        return: {
            name: null;
            type: void;
        };
    };
    childCompiler: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").AsyncParallelHook<any, any, any>;
        args: [{
            name: "pitchCompilerContext";
            type: import("../types/context").PitchCompilerContext<import("../types/subclassing-abstract").AbstractMiniExtractPlugin<{}, import("../types/subclassing-params").ParamsParse<{}>>>;
        }];
        return: {
            name: null;
            type: void;
        };
    };
    source: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").AsyncSeriesWaterfallHook<any, any, any>;
        args: [{
            name: "pitchCompilationContext";
            type: import("../types/context").PitchCompilationContext<import("../types/subclassing-abstract").AbstractMiniExtractPlugin<{}, import("../types/subclassing-params").ParamsParse<{}>>>;
        }];
        return: {
            name: null;
            type: string;
        };
    };
    childCompilation: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncHook<any, any, any>;
        args: [{
            name: "pitchCompilationContext";
            type: import("../types/context").PitchCompilationContext<import("../types/subclassing-abstract").AbstractMiniExtractPlugin<{}, import("../types/subclassing-params").ParamsParse<{}>>>;
        }];
        return: {
            name: null;
            type: void;
        };
    };
    dependency: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncWaterfallHook<any, any, any>;
        args: [{
            name: "pitchCompilationContext";
            type: import("../types/context").PitchCompilationContext<import("../types/subclassing-abstract").AbstractMiniExtractPlugin<{}, import("../types/subclassing-params").ParamsParse<{}>>>;
        }, {
            name: "loaderModuleContext";
            type: import("../types/context").LoaderModuleContext;
        }];
        return: {
            name: null;
            type: any[];
        };
    };
    extracted: {
        hook: new (...[args]: any[]) => import("../types/hook-definition").SyncWaterfallHook<any, any, any>;
        args: [{
            name: "pitchCompilationContext";
            type: import("../types/context").PitchCompilationContext<import("../types/subclassing-abstract").AbstractMiniExtractPlugin<{}, import("../types/subclassing-params").ParamsParse<{}>>>;
        }, {
            name: "remainingSource";
            type: string;
        }];
        return: {
            name: null;
            type: string;
        };
    };
}, "source" | "dependency" | "pitch" | "initialize" | "compiler" | "compilation" | "beforeRenderMain" | "renderMain" | "afterRenderMain" | "beforeRenderChunk" | "renderChunk" | "afterRenderChunk" | "beforeMerge" | "merge" | "afterMerge" | "childCompiler" | "childCompilation" | "extracted">;
export declare function isHookAsync(hook: Hook): boolean;
export declare function tapMany(pluginName: string, hooksObj: Collection, overrides: Overrides): void;
export declare function callTap<N extends ActiveHookNames = ActiveHookNames, H extends ActiveHooks = ActiveHooks, F extends AnyFunc = Taps[N], FP extends Parameters<F> = Parameters<F>, FR extends ReturnType<F> = ReturnType<F>, D extends FR = FR, R extends N extends ActiveAsyncHookNames ? Promise<FR> : FR = N extends ActiveAsyncHookNames ? Promise<FR> : FR>({ name, hooks, args, default: defaultVal, }: {
    name: N;
    hooks: H;
    args: FP;
    default?: D;
}): R;
