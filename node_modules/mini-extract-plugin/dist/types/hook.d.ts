import type tapable from 'tapable';
import type { FirstNRequiredVariadicTuple, AnyFunc, OmitType } from './util';
import type { AbstractMiniExtractPlugin } from './subclassing-abstract';
import type { HookDefinitions, HookDefinition, AsyncSeriesWaterfallHookClass, AsyncSeriesBailHookClass, AsyncSeriesHookClass, AsyncParallelBailHookClass, AsyncParallelBailHook, AsyncSeriesWaterfallHook, AsyncSeriesBailHook, AsyncSeriesHook, AsyncParallelHookClass, AsyncParallelHook, SyncLoopHookClass, SyncBailHookClass, SyncLoopHook, SyncBailHook, SyncWaterfallHookClass, SyncHookClass, SyncWaterfallHook, SyncHook } from './hook-definition';
export * from './hook-definition';
declare type HookInstanceFromClass<T, Arg1 = any, Arg2 = any, Arg3 = any> = T extends AsyncSeriesWaterfallHookClass ? AsyncSeriesWaterfallHook<Arg1, Arg2, Arg3> : T extends AsyncSeriesBailHookClass ? AsyncSeriesBailHook<Arg1, Arg2, Arg3> : T extends AsyncSeriesHookClass ? AsyncSeriesHook<Arg1, Arg2, Arg3> : T extends AsyncParallelBailHookClass ? AsyncParallelBailHook<Arg1, Arg2, Arg3> : T extends AsyncParallelHookClass ? AsyncParallelHook<Arg1, Arg2, Arg3> : T extends SyncLoopHookClass ? SyncLoopHook<Arg1, Arg2, Arg3> : T extends SyncBailHookClass ? SyncBailHook<Arg1, Arg2, Arg3> : T extends SyncWaterfallHookClass ? SyncWaterfallHook<Arg1, Arg2, Arg3> : T extends SyncHookClass ? SyncHook<Arg1, Arg2, Arg3> : T extends tapable.Hook ? tapable.Hook<Arg1, Arg2, Arg3> : never;
export declare type AsyncHookType = AsyncParallelBailHook | AsyncParallelHook | AsyncSeriesBailHook | AsyncSeriesHook | AsyncSeriesWaterfallHook;
export declare type SyncHookType = SyncHook | SyncBailHook | SyncWaterfallHook | SyncLoopHook;
export declare type Hooks<T extends HookDefinitions, K extends keyof T = keyof T> = {
    [Key in K]: HookInstanceFromClass<T[Key]['hook'], T[Key]['args'][0]['type'], T[Key]['args'][1]['type'], T[Key]['args'][2]['type']>;
};
declare class ActiveHookDefinitionsHelper<MEP extends AbstractMiniExtractPlugin = AbstractMiniExtractPlugin> {
    fixate: () => {
        initialize: {
            hook: new (...[args]: any[]) => SyncHook<any, any, any>;
            args: [{
                name: "instance";
                type: MEP;
            }, {
                name: "options";
                type: MEP["options"];
            }];
            return: {
                name: null;
                type: void;
            };
        };
        compiler: {
            hook: new (...[args]: any[]) => SyncHook<any, any, any>;
            args: [{
                name: "compilerContext";
                type: import("./context").CompilerContext<MEP>;
            }];
            return: {
                name: null;
                type: void;
            };
        };
        compilation: {
            hook: new (...[args]: any[]) => SyncHook<any, any, any>;
            args: [{
                name: "compilationContext";
                type: import("./context").CompilationContext<MEP>;
            }];
            return: {
                name: null;
                type: void;
            };
        };
        beforeRenderMain: {
            hook: new (...[args]: any[]) => SyncWaterfallHook<any, any, any>;
            args: [{
                name: "renderContext";
                type: import("./context").RenderContext<MEP>;
            }, {
                name: "modules";
                type: InstanceType<MEP["classOptions"]["moduleClass"]>[];
            }];
            return: {
                name: null;
                type: InstanceType<MEP["classOptions"]["moduleClass"]>[] | InstanceType<MEP["classOptions"]["moduleClass"]>[][];
            };
        };
        renderMain: {
            hook: new (...[args]: any[]) => SyncWaterfallHook<any, any, any>;
            args: [{
                name: "renderContext";
                type: import("./context").RenderContext<MEP>;
            }, {
                name: "moduleGroups";
                type: InstanceType<MEP["classOptions"]["moduleClass"]>[][];
            }];
            return: {
                name: null;
                type: import("./webpack").RenderManifestEntry[];
            };
        };
        afterRenderMain: {
            hook: new (...[args]: any[]) => SyncHook<any, any, any>;
            args: [{
                name: "renderContext";
                type: import("./context").RenderContext<MEP>;
            }, {
                name: "renderManifestEntries";
                type: import("./webpack").RenderManifestEntry[];
            }];
            return: {
                name: null;
                type: void;
            };
        };
        beforeRenderChunk: {
            hook: new (...[args]: any[]) => SyncWaterfallHook<any, any, any>;
            args: [{
                name: "renderContext";
                type: import("./context").RenderContext<MEP>;
            }, {
                name: "modules";
                type: InstanceType<MEP["classOptions"]["moduleClass"]>[];
            }];
            return: {
                name: null;
                type: InstanceType<MEP["classOptions"]["moduleClass"]>[] | InstanceType<MEP["classOptions"]["moduleClass"]>[][];
            };
        };
        renderChunk: {
            hook: new (...[args]: any[]) => SyncWaterfallHook<any, any, any>;
            args: [{
                name: "renderContext";
                type: import("./context").RenderContext<MEP>;
            }, {
                name: "moduleGroups";
                type: InstanceType<MEP["classOptions"]["moduleClass"]>[][];
            }];
            return: {
                name: null;
                type: import("./webpack").RenderManifestEntry[];
            };
        };
        afterRenderChunk: {
            hook: new (...[args]: any[]) => SyncHook<any, any, any>;
            args: [{
                name: "renderContext";
                type: import("./context").RenderContext<MEP>;
            }, {
                name: "renderManifestEntries";
                type: import("./webpack").RenderManifestEntry[];
            }];
            return: {
                name: null;
                type: void;
            };
        };
        beforeMerge: {
            hook: new (...[args]: any[]) => SyncWaterfallHook<any, any, any>;
            args: [{
                name: "renderContext";
                type: import("./context").RenderContext<MEP>;
            }, {
                name: "modules";
                type: InstanceType<MEP["classOptions"]["moduleClass"]>[];
            }];
            return: {
                name: null;
                type: InstanceType<MEP["classOptions"]["moduleClass"]>[];
            };
        };
        merge: {
            hook: new (...[args]: any[]) => SyncWaterfallHook<any, any, any>;
            args: [{
                name: "renderContext";
                type: import("./context").RenderContext<MEP>;
            }, {
                name: "modules";
                type: InstanceType<MEP["classOptions"]["moduleClass"]>[];
            }];
            return: {
                name: null;
                type: import("webpack-sources").Source;
            };
        };
        afterMerge: {
            hook: new (...[args]: any[]) => SyncHook<any, any, any>;
            args: [{
                name: "renderContext";
                type: import("./context").RenderContext<MEP>;
            }, {
                name: "resultSource";
                type: import("webpack-sources").Source;
            }];
            return: {
                name: null;
                type: void;
            };
        };
        pitch: {
            hook: new (...[args]: any[]) => AsyncParallelHook<any, any, any>;
            args: [{
                name: "pitchContext";
                type: import("./context").PitchContext<MEP>;
            }];
            return: {
                name: null;
                type: void;
            };
        };
        childCompiler: {
            hook: new (...[args]: any[]) => AsyncParallelHook<any, any, any>;
            args: [{
                name: "pitchCompilerContext";
                type: import("./context").PitchCompilerContext<MEP>;
            }];
            return: {
                name: null;
                type: void;
            };
        };
        source: {
            hook: new (...[args]: any[]) => AsyncSeriesWaterfallHook<any, any, any>;
            args: [{
                name: "pitchCompilationContext";
                type: import("./context").PitchCompilationContext<MEP>;
            }];
            return: {
                name: null;
                type: string;
            };
        };
        childCompilation: {
            hook: new (...[args]: any[]) => SyncHook<any, any, any>;
            args: [{
                name: "pitchCompilationContext";
                type: import("./context").PitchCompilationContext<MEP>;
            }];
            return: {
                name: null;
                type: void;
            };
        };
        dependency: {
            hook: new (...[args]: any[]) => SyncWaterfallHook<any, any, any>;
            args: [{
                name: "pitchCompilationContext";
                type: import("./context").PitchCompilationContext<MEP>;
            }, {
                name: "loaderModuleContext";
                type: import("./context").LoaderModuleContext;
            }];
            return: {
                name: null;
                type: ConstructorParameters<MEP["classOptions"]["dependencyClass"]>[0][];
            };
        };
        extracted: {
            hook: new (...[args]: any[]) => SyncWaterfallHook<any, any, any>;
            args: [{
                name: "pitchCompilationContext";
                type: import("./context").PitchCompilationContext<MEP>;
            }, {
                name: "remainingSource";
                type: string;
            }];
            return: {
                name: null;
                type: string;
            };
        };
    };
}
export declare type ActiveHookDefinitions<MEP extends AbstractMiniExtractPlugin = AbstractMiniExtractPlugin> = ReturnType<ActiveHookDefinitionsHelper<MEP>['fixate']>;
declare class ActiveHooksHelper<MEP extends AbstractMiniExtractPlugin = AbstractMiniExtractPlugin> {
    fixate: () => Hooks<{
        initialize: {
            hook: new (...[args]: any[]) => SyncHook<any, any, any>;
            args: [{
                name: "instance";
                type: MEP;
            }, {
                name: "options";
                type: MEP["options"];
            }];
            return: {
                name: null;
                type: void;
            };
        };
        compiler: {
            hook: new (...[args]: any[]) => SyncHook<any, any, any>;
            args: [{
                name: "compilerContext";
                type: import("./context").CompilerContext<MEP>;
            }];
            return: {
                name: null;
                type: void;
            };
        };
        compilation: {
            hook: new (...[args]: any[]) => SyncHook<any, any, any>;
            args: [{
                name: "compilationContext";
                type: import("./context").CompilationContext<MEP>;
            }];
            return: {
                name: null;
                type: void;
            };
        };
        beforeRenderMain: {
            hook: new (...[args]: any[]) => SyncWaterfallHook<any, any, any>;
            args: [{
                name: "renderContext";
                type: import("./context").RenderContext<MEP>;
            }, {
                name: "modules";
                type: InstanceType<MEP["classOptions"]["moduleClass"]>[];
            }];
            return: {
                name: null;
                type: InstanceType<MEP["classOptions"]["moduleClass"]>[] | InstanceType<MEP["classOptions"]["moduleClass"]>[][];
            };
        };
        renderMain: {
            hook: new (...[args]: any[]) => SyncWaterfallHook<any, any, any>;
            args: [{
                name: "renderContext";
                type: import("./context").RenderContext<MEP>;
            }, {
                name: "moduleGroups";
                type: InstanceType<MEP["classOptions"]["moduleClass"]>[][];
            }];
            return: {
                name: null;
                type: import("./webpack").RenderManifestEntry[];
            };
        };
        afterRenderMain: {
            hook: new (...[args]: any[]) => SyncHook<any, any, any>;
            args: [{
                name: "renderContext";
                type: import("./context").RenderContext<MEP>;
            }, {
                name: "renderManifestEntries";
                type: import("./webpack").RenderManifestEntry[];
            }];
            return: {
                name: null;
                type: void;
            };
        };
        beforeRenderChunk: {
            hook: new (...[args]: any[]) => SyncWaterfallHook<any, any, any>;
            args: [{
                name: "renderContext";
                type: import("./context").RenderContext<MEP>;
            }, {
                name: "modules";
                type: InstanceType<MEP["classOptions"]["moduleClass"]>[];
            }];
            return: {
                name: null;
                type: InstanceType<MEP["classOptions"]["moduleClass"]>[] | InstanceType<MEP["classOptions"]["moduleClass"]>[][];
            };
        };
        renderChunk: {
            hook: new (...[args]: any[]) => SyncWaterfallHook<any, any, any>;
            args: [{
                name: "renderContext";
                type: import("./context").RenderContext<MEP>;
            }, {
                name: "moduleGroups";
                type: InstanceType<MEP["classOptions"]["moduleClass"]>[][];
            }];
            return: {
                name: null;
                type: import("./webpack").RenderManifestEntry[];
            };
        };
        afterRenderChunk: {
            hook: new (...[args]: any[]) => SyncHook<any, any, any>;
            args: [{
                name: "renderContext";
                type: import("./context").RenderContext<MEP>;
            }, {
                name: "renderManifestEntries";
                type: import("./webpack").RenderManifestEntry[];
            }];
            return: {
                name: null;
                type: void;
            };
        };
        beforeMerge: {
            hook: new (...[args]: any[]) => SyncWaterfallHook<any, any, any>;
            args: [{
                name: "renderContext";
                type: import("./context").RenderContext<MEP>;
            }, {
                name: "modules";
                type: InstanceType<MEP["classOptions"]["moduleClass"]>[];
            }];
            return: {
                name: null;
                type: InstanceType<MEP["classOptions"]["moduleClass"]>[];
            };
        };
        merge: {
            hook: new (...[args]: any[]) => SyncWaterfallHook<any, any, any>;
            args: [{
                name: "renderContext";
                type: import("./context").RenderContext<MEP>;
            }, {
                name: "modules";
                type: InstanceType<MEP["classOptions"]["moduleClass"]>[];
            }];
            return: {
                name: null;
                type: import("webpack-sources").Source;
            };
        };
        afterMerge: {
            hook: new (...[args]: any[]) => SyncHook<any, any, any>;
            args: [{
                name: "renderContext";
                type: import("./context").RenderContext<MEP>;
            }, {
                name: "resultSource";
                type: import("webpack-sources").Source;
            }];
            return: {
                name: null;
                type: void;
            };
        };
        pitch: {
            hook: new (...[args]: any[]) => AsyncParallelHook<any, any, any>;
            args: [{
                name: "pitchContext";
                type: import("./context").PitchContext<MEP>;
            }];
            return: {
                name: null;
                type: void;
            };
        };
        childCompiler: {
            hook: new (...[args]: any[]) => AsyncParallelHook<any, any, any>;
            args: [{
                name: "pitchCompilerContext";
                type: import("./context").PitchCompilerContext<MEP>;
            }];
            return: {
                name: null;
                type: void;
            };
        };
        source: {
            hook: new (...[args]: any[]) => AsyncSeriesWaterfallHook<any, any, any>;
            args: [{
                name: "pitchCompilationContext";
                type: import("./context").PitchCompilationContext<MEP>;
            }];
            return: {
                name: null;
                type: string;
            };
        };
        childCompilation: {
            hook: new (...[args]: any[]) => SyncHook<any, any, any>;
            args: [{
                name: "pitchCompilationContext";
                type: import("./context").PitchCompilationContext<MEP>;
            }];
            return: {
                name: null;
                type: void;
            };
        };
        dependency: {
            hook: new (...[args]: any[]) => SyncWaterfallHook<any, any, any>;
            args: [{
                name: "pitchCompilationContext";
                type: import("./context").PitchCompilationContext<MEP>;
            }, {
                name: "loaderModuleContext";
                type: import("./context").LoaderModuleContext;
            }];
            return: {
                name: null;
                type: ConstructorParameters<MEP["classOptions"]["dependencyClass"]>[0][];
            };
        };
        extracted: {
            hook: new (...[args]: any[]) => SyncWaterfallHook<any, any, any>;
            args: [{
                name: "pitchCompilationContext";
                type: import("./context").PitchCompilationContext<MEP>;
            }, {
                name: "remainingSource";
                type: string;
            }];
            return: {
                name: null;
                type: string;
            };
        };
    }, "source" | "dependency" | "pitch" | "initialize" | "compiler" | "compilation" | "beforeRenderMain" | "renderMain" | "afterRenderMain" | "beforeRenderChunk" | "renderChunk" | "afterRenderChunk" | "beforeMerge" | "merge" | "afterMerge" | "childCompiler" | "childCompilation" | "extracted">;
}
export declare type ActiveHooks<MEP extends AbstractMiniExtractPlugin = AbstractMiniExtractPlugin> = ReturnType<ActiveHooksHelper<MEP>['fixate']>;
export declare type ActiveHookNames = keyof ActiveHooks;
export declare type ActiveAsyncHooks<MEP extends AbstractMiniExtractPlugin = AbstractMiniExtractPlugin> = OmitType<ActiveHooks<MEP>, SyncHookType>;
export declare type ActiveAsyncHookNames = keyof ActiveAsyncHooks;
export declare type ActiveSyncHooks<MEP extends AbstractMiniExtractPlugin = AbstractMiniExtractPlugin> = OmitType<ActiveHooks<MEP>, AsyncHookType>;
export declare type ActiveSyncHookNames = keyof ActiveSyncHooks;
export declare type Taps<MEP extends AbstractMiniExtractPlugin = AbstractMiniExtractPlugin, D extends ActiveHookDefinitions<MEP> = ActiveHookDefinitions<MEP>, H extends ActiveHooks<MEP> = ActiveHooks<MEP>, DK extends keyof D & keyof H = keyof D & keyof H> = {
    [K in DK]: H[K] extends tapable.Hook ? (...args: FirstNRequiredVariadicTuple<3, Parameters<H[K]['call']>>) => D[K] extends HookDefinition ? D[K]['return']['type'] : undefined : undefined;
};
export declare type PartialTaps<MEP extends AbstractMiniExtractPlugin = AbstractMiniExtractPlugin> = Partial<Taps<MEP>>;
export declare type TapTypes = 'tap' | 'tapAsync' | 'tapPromise' | 'intercept';
export declare type Override = {
    name: ActiveHookNames;
    type: TapTypes;
    hooks: Array<AnyFunc>;
};
export declare type Overrides = Override[];
export declare type Collection = {
    [key: string]: tapable.Hook;
};
