"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const webpack_1 = __importDefault(require("webpack"));
const debug_1 = __importDefault(require("../lib/debug"));
const hook_1 = require("../lib/hook");
const util_1 = require("../lib/util");
const get_module_filename_1 = __importDefault(require("../lib/get-module-filename"));
const render_content_asset_1 = __importDefault(require("../lib/render-content-asset"));
const default_filename_1 = __importDefault(require("../lib/default-filename"));
const createHash = webpack_1.default.util.createHash;
const REGEXP_CHUNKHASH = /\[chunkhash(?::(\d+))?\]/i;
const REGEXP_CONTENTHASH = /\[contenthash(?::(\d+))?\]/i;
const REGEXP_NAME = /\[name\]/i;
function apply(compiler) {
    debug_1.default('Started apply method');
    const context = {
        plugin: this,
        classOptions: this.classOptions,
        compiler,
        options: this.options,
    };
    hook_1.callTap({
        name: 'compiler',
        hooks: this.hooks,
        args: [context, undefined, undefined],
    });
    compiler.hooks.thisCompilation.tap(this.classOptions.pluginName, (compilation) => {
        debug_1.default('Started apply.compiler.thisCompilation');
        const compilationContext = Object.assign(Object.assign({}, context), { compilation });
        compilation.dependencyFactories.set(this.classOptions.dependencyClass, new this.classOptions.moduleFactoryClass());
        compilation.dependencyTemplates.set(this.classOptions.dependencyClass, new this.classOptions.dependencyTemplateClass());
        hook_1.callTap({
            name: 'compilation',
            hooks: this.hooks,
            args: [compilationContext, undefined, undefined],
        });
        compilation.mainTemplate.hooks.renderManifest.tap(this.classOptions.pluginName, (entries, options) => {
            debug_1.default('Started apply.compiler.thisCompilation.renderManifest');
            const { chunk } = options;
            const renderContext = Object.assign(Object.assign({}, context), { compilation, renderOptions: options, renderEntries: entries });
            const renderedModules = Array.from(chunk.modulesIterable).filter((module) => module.type === this.classOptions.moduleType);
            const modifiedModules = hook_1.callTap({
                name: 'beforeRenderMain',
                hooks: this.hooks,
                args: [renderContext, renderedModules, undefined],
                default: [renderedModules],
            });
            const moduleGroups = util_1.isIterOfIter(modifiedModules)
                ? modifiedModules
                : [modifiedModules];
            const res = hook_1.callTap({
                name: 'renderMain',
                hooks: this.hooks,
                args: [renderContext, moduleGroups, undefined],
            });
            if (res) {
                entries.push(...res);
                hook_1.callTap({
                    name: 'afterRenderMain',
                    hooks: this.hooks,
                    args: [renderContext, entries, undefined],
                });
                return;
            }
            debug_1.default('Hook renderMain is not used, running default implementation instead');
            for (const [index, moduleGroup] of util_1.enumerate(moduleGroups)) {
                if (!moduleGroup.length)
                    continue;
                entries.push({
                    render: () => render_content_asset_1.default({
                        ignoreOrder: Boolean(this.options.ignoreOrder),
                        context: renderContext,
                        modules: moduleGroup,
                    }),
                    filenameTemplate: (templateOptions) => get_module_filename_1.default({
                        default: default_filename_1.default(this.classOptions.type),
                        context: renderContext,
                        templateOptions,
                        modules: moduleGroup,
                    }),
                    pathOptions: {
                        chunk,
                        contentHashType: this.classOptions.moduleType,
                    },
                    identifier: `${this.classOptions.pluginName}.${chunk.id}.${index}`,
                    hash: chunk.contentHash[this.classOptions.moduleType],
                });
            }
            hook_1.callTap({
                name: 'afterRenderMain',
                hooks: this.hooks,
                args: [renderContext, entries, undefined],
            });
            debug_1.default('Done apply.compiler.thisCompilation.renderManifest');
        });
        compilation.chunkTemplate.hooks.renderManifest.tap(this.classOptions.pluginName, (entries, options) => {
            debug_1.default('Started apply.compiler.thisCompilation.chunkTemplate.renderManifest');
            const { chunk } = options;
            const renderContext = Object.assign(Object.assign({}, context), { compilation, renderOptions: options, renderEntries: entries });
            const renderedModules = Array.from(chunk.modulesIterable).filter((module) => module.type === this.classOptions.moduleType);
            const modifiedModules = hook_1.callTap({
                name: 'beforeRenderChunk',
                hooks: this.hooks,
                args: [renderContext, renderedModules, undefined],
                default: [renderedModules],
            });
            const moduleGroups = util_1.isIterOfIter(modifiedModules)
                ? modifiedModules
                : [modifiedModules];
            const res = hook_1.callTap({
                name: 'renderChunk',
                hooks: this.hooks,
                args: [renderContext, moduleGroups, undefined],
            });
            if (res) {
                entries.push(...res);
                hook_1.callTap({
                    name: 'afterRenderChunk',
                    hooks: this.hooks,
                    args: [renderContext, entries, undefined],
                });
                return;
            }
            debug_1.default('Hook renderChunk is not used, running default implementation instead');
            for (const [index, moduleGroup] of util_1.enumerate(moduleGroups)) {
                if (!moduleGroup.length)
                    continue;
                entries.push({
                    render: () => render_content_asset_1.default({
                        ignoreOrder: Boolean(this.options.ignoreOrder),
                        context: renderContext,
                        modules: moduleGroup,
                    }),
                    filenameTemplate: this.options.chunkFilename,
                    pathOptions: {
                        chunk,
                        contentHashType: this.classOptions.moduleType,
                    },
                    identifier: `${this.classOptions.pluginName}.${chunk.id}.${index}`,
                    hash: chunk.contentHash[this.classOptions.moduleType],
                });
            }
            hook_1.callTap({
                name: 'afterRenderChunk',
                hooks: this.hooks,
                args: [renderContext, entries, undefined],
            });
            debug_1.default('Done apply.compiler.thisCompilation.chunkTemplate.renderManifest');
        });
        compilation.mainTemplate.hooks.hashForChunk.tap(this.classOptions.pluginName, (hash, chunk) => {
            debug_1.default('Starting apply.compiler.thisCompilation.mainTemplate.hashForChunk');
            const { chunkFilename } = this.options;
            if (REGEXP_CHUNKHASH.test(chunkFilename)) {
                hash.update(JSON.stringify(chunk.getChunkMaps(true).hash));
            }
            if (REGEXP_CONTENTHASH.test(chunkFilename)) {
                hash.update(JSON.stringify(chunk.getChunkMaps(true).contentHash[this.classOptions.moduleType] || {}));
            }
            if (REGEXP_NAME.test(chunkFilename)) {
                hash.update(JSON.stringify(chunk.getChunkMaps(true).name));
            }
            debug_1.default('Done apply.compiler.thisCompilation.mainTemplate.hashForChunk');
        });
        compilation.hooks.contentHash.tap(this.classOptions.pluginName, (chunk) => {
            debug_1.default('Starting apply.compiler.thisCompilation.contentHash');
            const { outputOptions } = compilation;
            const { hashFunction, hashDigest, hashDigestLength } = outputOptions;
            const hash = createHash(hashFunction);
            for (const m of chunk.modulesIterable) {
                if (m.type === this.classOptions.moduleType)
                    m.updateHash(hash);
            }
            const { contentHash } = chunk;
            contentHash[this.classOptions.moduleType] = hash
                .digest(hashDigest)
                .substring(0, hashDigestLength);
            debug_1.default('Done apply.compiler.thisCompilation.contentHash');
        });
        debug_1.default('Finished apply.compiler.thisCompilation');
    });
    debug_1.default('Finished apply method');
}
exports.default = apply;
