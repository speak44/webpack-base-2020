"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const loader_utils_1 = __importDefault(require("loader-utils"));
const schema_utils_1 = __importDefault(require("schema-utils"));
const NodeTemplatePlugin_1 = __importDefault(require("webpack/lib/node/NodeTemplatePlugin"));
const NodeTargetPlugin_1 = __importDefault(require("webpack/lib/node/NodeTargetPlugin"));
const LibraryTemplatePlugin_1 = __importDefault(require("webpack/lib/LibraryTemplatePlugin"));
const SingleEntryPlugin_1 = __importDefault(require("webpack/lib/SingleEntryPlugin"));
const LimitChunkCountPlugin_1 = __importDefault(require("webpack/lib/optimize/LimitChunkCountPlugin"));
const debug_1 = __importDefault(require("../lib/debug"));
const hot_loader_1 = __importDefault(require("../lib/hot-loader"));
const moduleLib = __importStar(require("../lib/module"));
const hook_1 = require("../lib/hook");
function pitch(loaderContext, remainingRequest, precedingRequest, data) {
    return __awaiter(this, void 0, void 0, function* () {
        debug_1.default('Started pitch method');
        const callback = loaderContext.async();
        const pitchContext = {
            plugin: this,
            classOptions: this.classOptions,
            options: this.options,
            loaderContext,
            remainingRequest,
            precedingRequest,
            data,
        };
        yield hook_1.callTap({
            name: 'pitch',
            hooks: this.hooks,
            args: [pitchContext, undefined, undefined],
        });
        const options = loader_utils_1.default.getOptions(loaderContext) || {};
        schema_utils_1.default(this.classOptions.loaderOptionsSchema, options, `${this.classOptions.displayName} Loader`);
        const loaders = loaderContext.loaders.slice(loaderContext.loaderIndex + 1);
        loaderContext.addDependency(loaderContext.resourcePath);
        const childFilename = '*';
        const publicPath = typeof options.publicPath === 'string'
            ? options.publicPath === '' || options.publicPath.endsWith('/')
                ? options.publicPath
                : `${options.publicPath}/`
            : typeof options.publicPath === 'function'
                ? options.publicPath(loaderContext.resourcePath, loaderContext.rootContext)
                : loaderContext._compilation.outputOptions.publicPath;
        const outputOptions = {
            filename: childFilename,
            publicPath,
        };
        const childCompiler = loaderContext._compilation.createChildCompiler(`${this.classOptions.pluginName} ${remainingRequest}`, outputOptions);
        new NodeTemplatePlugin_1.default(outputOptions).apply(childCompiler);
        new LibraryTemplatePlugin_1.default(null, 'commonjs2').apply(childCompiler);
        new NodeTargetPlugin_1.default().apply(childCompiler);
        new SingleEntryPlugin_1.default(loaderContext.context, `!!${remainingRequest}`, this.classOptions.pluginName).apply(childCompiler);
        new LimitChunkCountPlugin_1.default({ maxChunks: 1 }).apply(childCompiler);
        const pitchCompilerContext = Object.assign(Object.assign({}, pitchContext), { childCompiler });
        yield hook_1.callTap({
            name: 'childCompiler',
            hooks: this.hooks,
            args: [pitchCompilerContext, undefined, undefined],
        });
        childCompiler.hooks.thisCompilation.tap(`${this.classOptions.pluginName} loader`, (compilation) => {
            debug_1.default('Started pitch.childCompiler.thisCompilation');
            compilation.hooks.normalModuleLoader.tap(`${this.classOptions.pluginName} loader`, (childLoaderContext, module) => {
                debug_1.default('Started pitch.childCompiler.thisCompilation.normalModuleLoader');
                const mod = module;
                childLoaderContext.emitFile = loaderContext.emitFile;
                if (mod.request === remainingRequest) {
                    module.loaders = loaders.map((loader) => {
                        return {
                            loader: loader.path,
                            options: loader.options,
                            ident: loader.ident,
                        };
                    });
                }
                debug_1.default('Done pitch.childCompiler.thisCompilation.normalModuleLoader');
            });
            debug_1.default('Done pitch.childCompiler.thisCompilation');
        });
        let source;
        childCompiler.hooks.afterCompile.tapPromise(this.classOptions.pluginName, (compilation) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            debug_1.default('Started pitch.childCompiler.afterCompile');
            const pitchCompilationContext = Object.assign(Object.assign({}, pitchCompilerContext), { childCompilation: compilation });
            source = yield hook_1.callTap({
                name: 'source',
                hooks: this.hooks,
                args: [pitchCompilationContext, undefined, undefined],
                default: (_a = compilation.assets[childFilename]) === null || _a === void 0 ? void 0 : _a.source(),
            });
            compilation.chunks.forEach((chunk) => {
                chunk.files.forEach((file) => {
                    delete compilation.assets[file];
                });
            });
            debug_1.default('Done pitch.childCompiler.afterCompile');
        }));
        childCompiler.runAsChild((err, entries, compilation) => {
            debug_1.default('Started pitch.childCompiler.runAsChild');
            const pitchCompilationContext = Object.assign(Object.assign({}, pitchCompilerContext), { childCompilation: compilation });
            hook_1.callTap({
                name: 'childCompilation',
                hooks: this.hooks,
                args: [pitchCompilationContext, undefined, undefined],
            });
            const addDependencies = (dependencies) => {
                if (!Array.isArray(dependencies) && dependencies != null) {
                    throw new Error(`Exported value was not extracted as an array: ${JSON.stringify(dependencies)}`);
                }
                const identifierCountMap = new Map();
                for (const dependency of dependencies) {
                    const count = identifierCountMap.get(dependency.identifier) || 0;
                    loaderContext._module.addDependency(new this.classOptions.dependencyClass(dependency, dependency.context, count));
                    identifierCountMap.set(dependency.identifier, count + 1);
                }
            };
            if (err)
                return callback(err);
            if (compilation.errors.length > 0) {
                return callback(compilation.errors[0]);
            }
            compilation.fileDependencies.forEach((dep) => {
                loaderContext.addDependency(dep);
            }, loaderContext);
            compilation.contextDependencies.forEach((dep) => {
                loaderContext.addContextDependency(dep);
            }, loaderContext);
            if (!source) {
                return callback(new Error("Didn't get a result from child compiler"));
            }
            let locals;
            try {
                debug_1.default(`Evaluating source of module "${remainingRequest}"`);
                let exports = moduleLib.evalCode(loaderContext, source, remainingRequest);
                exports = exports.__esModule ? exports.default : exports;
                locals = exports && exports.locals;
                const exportsData = !Array.isArray(exports)
                    ? [[null, exports]]
                    : exports;
                const loaderModuleContext = { source, locals, exports: exportsData };
                const dependencies = [];
                let deps = hook_1.callTap({
                    name: 'dependency',
                    hooks: this.hooks,
                    args: [pitchCompilationContext, loaderModuleContext, undefined],
                });
                if (deps === undefined) {
                    deps = [];
                    for (const [id, content] of exportsData) {
                        const mod = moduleLib.findById(compilation.modules, id);
                        if (!mod)
                            continue;
                        deps.push({
                            identifier: mod.identifier(),
                            context: mod.context,
                            content,
                            miniExtractType: this.classOptions.type,
                            moduleType: this.classOptions.moduleType,
                        });
                    }
                }
                dependencies.push(...deps);
                addDependencies(dependencies);
            }
            catch (e) {
                return callback(e);
            }
            const esModule = typeof options.esModule !== 'undefined' ? options.esModule : false;
            const result = locals
                ? `\n${esModule ? 'export default' : 'module.exports ='} ${JSON.stringify(locals)};`
                : '';
            let resultSource = `// extracted by ${this.classOptions.pluginName}`;
            resultSource += options.hmr
                ? hot_loader_1.default(result, {
                    context: loaderContext.context,
                    options,
                    locals,
                    type: this.classOptions.type,
                })
                : result;
            resultSource = hook_1.callTap({
                name: 'extracted',
                hooks: this.hooks,
                args: [pitchCompilationContext, resultSource, undefined],
                default: resultSource,
            });
            debug_1.default('Done pitch.childCompiler.runAsChild');
            debug_1.default('Calling loaderContext async callback in pitch');
            return callback(null, resultSource);
        });
        debug_1.default('Done pitch method');
    });
}
exports.default = pitch;
